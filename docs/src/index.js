/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/ast/ast.ts":
/*!************************!*\
  !*** ./src/ast/ast.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass Program {\r\n    constructor() {\r\n        this.Statements = [];\r\n    }\r\n    TokenLiteral() {\r\n        if (this.Statements.length > 0) {\r\n            return this.Statements[\"0\"].TokenLiteral();\r\n        }\r\n        return \"\";\r\n    }\r\n    String() {\r\n        let s = \"\";\r\n        this.Statements.forEach(element => {\r\n            s += (element.Node().String());\r\n        });\r\n        return s;\r\n    }\r\n}\r\nexports.Program = Program;\r\nclass LetStatement {\r\n    StatementNode() { }\r\n    Node() {\r\n        return this;\r\n    }\r\n    TokenLiteral() { return this.Token.Literal; }\r\n    String() {\r\n        return `${this.TokenLiteral()} ${this.Name.String()} = ${this.Value.Node().String()};`;\r\n    }\r\n}\r\nexports.LetStatement = LetStatement;\r\nclass ReturnStatement {\r\n    StatementNode() { }\r\n    Node() {\r\n        return this;\r\n    }\r\n    TokenLiteral() { return this.Token.Literal; }\r\n    String() {\r\n        return `${this.TokenLiteral()} ${this.ReturnValue.Node().String()};`;\r\n    }\r\n}\r\nexports.ReturnStatement = ReturnStatement;\r\nclass ExpressionStatement {\r\n    StatementNode() { }\r\n    TokenLiteral() { return this.Token.Literal; }\r\n    Node() {\r\n        return this;\r\n    }\r\n    String() {\r\n        return this.Expression.Node().String();\r\n    }\r\n}\r\nexports.ExpressionStatement = ExpressionStatement;\r\nclass PrefixExpression {\r\n    ExpressionNode() { }\r\n    Node() {\r\n        return this;\r\n    }\r\n    TokenLiteral() { return this.Token.Literal; }\r\n    String() {\r\n        let out = \"(\";\r\n        out += this.Operator;\r\n        out += this.Right.Node().String();\r\n        out += \")\";\r\n        return out;\r\n    }\r\n}\r\nexports.PrefixExpression = PrefixExpression;\r\nclass InfixExpression {\r\n    ExpressionNode() { }\r\n    Node() {\r\n        return this;\r\n    }\r\n    TokenLiteral() { return this.Token.Literal; }\r\n    String() {\r\n        let out = \"(\";\r\n        out += this.Left.Node().String();\r\n        out += \" \";\r\n        out += this.Operator;\r\n        out += \" \";\r\n        out += this.Right.Node().String();\r\n        out += \")\";\r\n        return out;\r\n    }\r\n}\r\nexports.InfixExpression = InfixExpression;\r\nclass Identifier {\r\n    Node() {\r\n        return this;\r\n    }\r\n    ExpressionNode() { }\r\n    TokenLiteral() { return this.Token.Literal; }\r\n    String() {\r\n        return this.Value;\r\n    }\r\n}\r\nexports.Identifier = Identifier;\r\nclass IntegerLiteral {\r\n    ExpressionNode() { }\r\n    Node() {\r\n        return this;\r\n    }\r\n    TokenLiteral() { return this.Token.Literal; }\r\n    String() { return this.Token.Literal; }\r\n}\r\nexports.IntegerLiteral = IntegerLiteral;\r\nclass Bool {\r\n    ExpressionNode() { }\r\n    Node() { return this; }\r\n    TokenLiteral() { return this.Token.Literal; }\r\n    String() { return this.Token.Literal; }\r\n}\r\nexports.Bool = Bool;\r\nclass IfExpression {\r\n    ExpressionNode() { }\r\n    TokenLiteral() { return this.Token.Literal; }\r\n    Node() {\r\n        return this;\r\n    }\r\n    String() {\r\n        var out = \"if \";\r\n        out += this.Condition.Node().String();\r\n        out += \" \";\r\n        out += this.Consequence.Node().String();\r\n        if (this.Alternative != null) {\r\n            out += \" else \";\r\n            out += this.Alternative.Node().String();\r\n        }\r\n        return out;\r\n    }\r\n}\r\nexports.IfExpression = IfExpression;\r\nclass BlockStatement {\r\n    Node() { return this; }\r\n    StatementNode() { }\r\n    TokenLiteral() { return this.Token.Literal; }\r\n    String() {\r\n        var out = \"\";\r\n        this.Statements.forEach(s => {\r\n            out += s.Node().String();\r\n        });\r\n        return out;\r\n    }\r\n}\r\nexports.BlockStatement = BlockStatement;\r\nclass FunctionLiteral {\r\n    ExpressionNode() { }\r\n    Node() {\r\n        return this;\r\n    }\r\n    TokenLiteral() { return this.Token.Literal; }\r\n    String() {\r\n        let out = \"\";\r\n        let params = [];\r\n        this.Parameters.forEach(param => {\r\n            params.push(param.String());\r\n        });\r\n        out += this.TokenLiteral();\r\n        out += \"(\";\r\n        out += params.join(\", \");\r\n        out += \") \";\r\n        out += this.Body.String();\r\n        return out;\r\n    }\r\n}\r\nexports.FunctionLiteral = FunctionLiteral;\r\nclass StringLiteral {\r\n    Node() { return this; }\r\n    ExpressionNode() { }\r\n    TokenLiteral() { return this.Token.Literal; }\r\n    String() { return this.Token.Literal; }\r\n}\r\nexports.StringLiteral = StringLiteral;\r\nclass CallExpression {\r\n    ExpressionNode() { }\r\n    TokenLiteral() { return this.Token.Literal; }\r\n    Node() {\r\n        return this;\r\n    }\r\n    String() {\r\n        let out = \"\";\r\n        let args = [];\r\n        this.Arguments.forEach(arg => {\r\n            args.push(arg.Node().String());\r\n        });\r\n        out += this.Function.Node().String();\r\n        out += \"(\";\r\n        out += args.join(\", \");\r\n        out += \")\";\r\n        return out;\r\n    }\r\n}\r\nexports.CallExpression = CallExpression;\r\n\n\n//# sourceURL=webpack:///./src/ast/ast.ts?");

/***/ }),

/***/ "./src/evaluator/evaluator.ts":
/*!************************************!*\
  !*** ./src/evaluator/evaluator.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst ast = __webpack_require__(/*! ../ast/ast */ \"./src/ast/ast.ts\");\r\nconst object = __webpack_require__(/*! ../object/object */ \"./src/object/object.ts\");\r\nconst environment_1 = __webpack_require__(/*! ../object/environment */ \"./src/object/environment.ts\");\r\nconst TRUE = new object.Bool(true);\r\nconst FALSE = new object.Bool(false);\r\nconst NULL = new object.Null();\r\nfunction GetNULL() {\r\n    return NULL;\r\n}\r\nexports.GetNULL = GetNULL;\r\nfunction Evaluate(node, e) {\r\n    if (node instanceof ast.Program) {\r\n        return EvaluateProgram(node, e);\r\n    }\r\n    else if (node instanceof ast.ExpressionStatement) {\r\n        return Evaluate(node.Expression.Node(), e);\r\n    }\r\n    else if (node instanceof ast.LetStatement) {\r\n        let v = Evaluate(node.Value.Node(), e);\r\n        if (isError(v)) {\r\n            return v;\r\n        }\r\n        e.Set(node.Name.Value, v);\r\n    }\r\n    else if (node instanceof ast.ReturnStatement) {\r\n        let v = Evaluate(node.ReturnValue.Node(), e);\r\n        if (isError(v)) {\r\n            return v;\r\n        }\r\n        let rv = new object.ReturnValue();\r\n        rv.Value = v;\r\n        return rv;\r\n    }\r\n    else if (node instanceof ast.BlockStatement) {\r\n        return EvaluateBlockStatement(node, e);\r\n    }\r\n    else if (node instanceof ast.IntegerLiteral) {\r\n        return new object.Integer(node.Value);\r\n    }\r\n    else if (node instanceof ast.Bool) {\r\n        return nativeBoolObject(node.Value.valueOf());\r\n    }\r\n    else if (node instanceof ast.StringLiteral) {\r\n        let s = new object.String();\r\n        s.Value = node.Value;\r\n        return s;\r\n    }\r\n    else if (node instanceof ast.Identifier) {\r\n        return EvaluateIdentifier(node, e);\r\n    }\r\n    else if (node instanceof ast.FunctionLiteral) {\r\n        let p = node.Parameters;\r\n        let body = node.Body;\r\n        let f = new object.Function();\r\n        f.Parameters = p;\r\n        f.Body = body;\r\n        f.Env = e;\r\n        return f;\r\n    }\r\n    else if (node instanceof ast.PrefixExpression) {\r\n        let right = Evaluate(node.Right.Node(), e);\r\n        if (isError(right)) {\r\n            return right;\r\n        }\r\n        return EvaluatePrefixExpression(node.Operator, right);\r\n    }\r\n    else if (node instanceof ast.InfixExpression) {\r\n        let right = Evaluate(node.Right.Node(), e);\r\n        if (isError(right)) {\r\n            return right;\r\n        }\r\n        let left = Evaluate(node.Left.Node(), e);\r\n        if (isError(left)) {\r\n            return left;\r\n        }\r\n        return EvaluateInfixExpression(node.Operator, left, right);\r\n    }\r\n    else if (node instanceof ast.CallExpression) {\r\n        let f = Evaluate(node.Function.Node(), e);\r\n        if (isError(f)) {\r\n            return f;\r\n        }\r\n        let args = EvaluateExpression(node.Arguments, e);\r\n        if (args.length == 1 && isError(args[0])) {\r\n            return args[0];\r\n        }\r\n        return applyFunction(f, args);\r\n    }\r\n    else if (node instanceof ast.IfExpression) {\r\n        let condition = Evaluate(node.Condition.Node(), e);\r\n        if (isError(condition)) {\r\n            return condition;\r\n        }\r\n        if (isTruth(condition)) {\r\n            return Evaluate(node.Consequence, e);\r\n        }\r\n        else if (node.Alternative != null) {\r\n            return Evaluate(node.Alternative, e);\r\n        }\r\n        else {\r\n            return NULL;\r\n        }\r\n    }\r\n    return null;\r\n}\r\nexports.Evaluate = Evaluate;\r\nfunction isTruth(obj) {\r\n    switch (obj) {\r\n        case NULL:\r\n            return false;\r\n        case TRUE:\r\n            return true;\r\n        case FALSE:\r\n            return false;\r\n        default:\r\n            return true;\r\n    }\r\n}\r\nfunction isError(obj) {\r\n    if (obj != null) {\r\n        return obj.Type() == object.Type.ERROR_OBJ;\r\n    }\r\n    return false;\r\n}\r\nfunction EvaluateProgram(program, e) {\r\n    let obj;\r\n    for (let index = 0; index < program.Statements.length; index++) {\r\n        const statement = program.Statements[index];\r\n        obj = Evaluate(statement.Node(), e);\r\n        if (obj instanceof object.ReturnValue) {\r\n            return obj.Value;\r\n        }\r\n        if (obj instanceof object.Error) {\r\n            return obj;\r\n        }\r\n    }\r\n    return obj;\r\n}\r\nfunction EvaluateIdentifier(node, e) {\r\n    let v = e.Get(node.Value);\r\n    if (!v.exist) {\r\n        return NewError(`identifier not found: ${node.Value}`);\r\n    }\r\n    return v.value;\r\n}\r\nfunction EvaluatePrefixExpression(op, right) {\r\n    switch (op) {\r\n        case \"!\":\r\n            return EvaluateBangOperatorExpression(right);\r\n        case \"-\":\r\n            return EvaluateMinusOperatorExpression(right);\r\n        default:\r\n            return NewError(`unknown operator: ${op + right.Type()}`);\r\n    }\r\n}\r\nfunction EvaluateInfixExpression(op, left, right) {\r\n    if (left instanceof object.Integer && right instanceof object.Integer) {\r\n        return EvaluateIntegerInfixExpression(op, left, right);\r\n    }\r\n    // ch3p140\r\n    // As now now, Bool and Null objects are constant.\r\n    // So we can compare them by references.\r\n    else if (op == \"==\") {\r\n        return nativeBoolObject(left == right);\r\n    }\r\n    else if (op == \"!=\") {\r\n        return nativeBoolObject(left != right);\r\n    }\r\n    else if (left instanceof object.String && right instanceof object.String) {\r\n        return EvaluateStringInfixExpression(op, left, right);\r\n    }\r\n    else if (left.Type() != right.Type()) {\r\n        return NewError(`type mismatch: ${left.Type()} ${op} ${right.Type()}`);\r\n    }\r\n    return NewError(`unknown operator: ${left.Type()} ${op} ${right.Type()}`);\r\n}\r\nfunction EvaluateExpression(expressions, e) {\r\n    let results = [];\r\n    expressions.forEach(element => {\r\n        let got = Evaluate(element.Node(), e);\r\n        if (isError(got)) {\r\n            return results;\r\n        }\r\n        results.push(got);\r\n    });\r\n    return results;\r\n}\r\nfunction EvaluateBlockStatement(block, e) {\r\n    let v;\r\n    for (let index = 0; index < block.Statements.length; index++) {\r\n        const s = block.Statements[index];\r\n        v = Evaluate(s.Node(), e);\r\n        if (v instanceof object.ReturnValue) {\r\n            return v;\r\n        }\r\n        if (v instanceof object.Error) {\r\n            return v;\r\n        }\r\n    }\r\n    return v;\r\n}\r\nfunction nativeBoolObject(input) {\r\n    if (input) {\r\n        return TRUE;\r\n    }\r\n    return FALSE;\r\n}\r\nfunction EvaluateBangOperatorExpression(right) {\r\n    switch (right) {\r\n        case TRUE:\r\n            return FALSE;\r\n        case FALSE:\r\n            return TRUE;\r\n        case NULL:\r\n            return TRUE;\r\n        default:\r\n            return FALSE;\r\n    }\r\n}\r\nfunction EvaluateMinusOperatorExpression(right) {\r\n    if (!(right instanceof object.Integer)) {\r\n        return NewError(`unknown operator: -${right.Type()}`);\r\n    }\r\n    return new object.Integer(-1 * right.Value);\r\n}\r\nfunction EvaluateIntegerInfixExpression(op, left, right) {\r\n    switch (op) {\r\n        case \"+\":\r\n            return new object.Integer(left.Value + right.Value);\r\n        case \"-\":\r\n            return new object.Integer(left.Value - right.Value);\r\n        case \"/\":\r\n            return new object.Integer(left.Value / right.Value);\r\n        case \"*\":\r\n            return new object.Integer(left.Value * right.Value);\r\n        case \"<\":\r\n            return nativeBoolObject(left.Value < right.Value);\r\n        case \">\":\r\n            return nativeBoolObject(left.Value > right.Value);\r\n        case \"==\":\r\n            return nativeBoolObject(left.Value == right.Value);\r\n        case \"!=\":\r\n            return nativeBoolObject(left.Value != right.Value);\r\n        default:\r\n            return NewError(`unknown operator: ${left.Type()} ${op} ${right.Type()}`);\r\n    }\r\n}\r\nfunction EvaluateStringInfixExpression(op, left, right) {\r\n    switch (op) {\r\n        case \"+\":\r\n            let s = new object.String();\r\n            s.Value = left.Value + right.Value;\r\n            return s;\r\n        default:\r\n            return NewError(`unknown operator: ${left.Type()} ${op} ${right.Type()}`);\r\n    }\r\n}\r\nfunction applyFunction(f, args) {\r\n    if (f instanceof object.Function) {\r\n        let newEnv = ExtendedFunctionEnvironment(f, args);\r\n        let got = Evaluate(f.Body, newEnv);\r\n        return UnwrapReturnValue(got);\r\n    }\r\n    return NewError(`not a function: ${f.Type()}`);\r\n}\r\nfunction ExtendedFunctionEnvironment(f, args) {\r\n    let env = environment_1.NewEnclosedEnvironment(f.Env);\r\n    for (let index = 0; index < f.Parameters.length; index++) {\r\n        const element = f.Parameters[index];\r\n        env.Set(element.Value, args[index]);\r\n    }\r\n    return env;\r\n}\r\nfunction UnwrapReturnValue(obj) {\r\n    if (obj instanceof object.ReturnValue) {\r\n        return obj.Value;\r\n    }\r\n    return obj;\r\n}\r\nfunction NewError(msg) {\r\n    let e = new object.Error();\r\n    e.Message = msg;\r\n    return e;\r\n}\r\n\n\n//# sourceURL=webpack:///./src/evaluator/evaluator.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst lexer_1 = __webpack_require__(/*! ../src/lexer/lexer */ \"./src/lexer/lexer.ts\");\r\nconst parser_1 = __webpack_require__(/*! ./parser/parser */ \"./src/parser/parser.ts\");\r\nconst evaluator_1 = __webpack_require__(/*! ./evaluator/evaluator */ \"./src/evaluator/evaluator.ts\");\r\nconst environment_1 = __webpack_require__(/*! ./object/environment */ \"./src/object/environment.ts\");\r\nvar env = environment_1.NewEnvironment();\r\nvar src, run, out;\r\nfunction Run(input) {\r\n    let l = new lexer_1.Lexer(input);\r\n    let p = parser_1.Parser.New(l);\r\n    let program = p.ToProgram();\r\n    if (p.Errors().length != 0) {\r\n        return printParseErrors(p.Errors());\r\n    }\r\n    let got = evaluator_1.Evaluate(program, env);\r\n    if (got == null) {\r\n        return \"\";\r\n    }\r\n    return got.Inspect();\r\n}\r\nexports.Run = Run;\r\nfunction printParseErrors(errors) {\r\n    let out = \"\";\r\n    errors.forEach(e => {\r\n        out += `${e}\\n`;\r\n    });\r\n    return out;\r\n}\r\nonload = function () {\r\n    src = document.getElementById('text1');\r\n    out = document.getElementById('text2');\r\n    run = document.getElementById('run');\r\n    run.onclick = function () {\r\n        alert(\"aaa\");\r\n        let got = Run(src.innerText);\r\n        out.innerText = got;\r\n    };\r\n};\r\n\n\n//# sourceURL=webpack:///./src/index.ts?");

/***/ }),

/***/ "./src/lexer/lexer.ts":
/*!****************************!*\
  !*** ./src/lexer/lexer.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst token_1 = __webpack_require__(/*! ../token/token */ \"./src/token/token.ts\");\r\nclass Lexer {\r\n    constructor(input) {\r\n        this._input = input.split('');\r\n        this._current = \"\";\r\n        this._currentPosition = 0;\r\n        this._nextPosition = 0;\r\n        this.Read();\r\n    }\r\n    NextToken() {\r\n        var t;\r\n        this.SkipWhiteSpace();\r\n        let current = this._current;\r\n        switch (current) {\r\n            case \"=\":\r\n                if (this.Peek() == \"=\") {\r\n                    let s = this._current;\r\n                    this.Read();\r\n                    let literal = s + this._current;\r\n                    t = new token_1.Token(token_1.TokenType.EQ, s + this._current);\r\n                }\r\n                else {\r\n                    t = new token_1.Token(token_1.TokenType.ASSIGN, current);\r\n                }\r\n                break;\r\n            case \";\":\r\n                t = new token_1.Token(token_1.TokenType.SEMICOLON, current);\r\n                break;\r\n            case \"(\":\r\n                t = new token_1.Token(token_1.TokenType.LPAREN, current);\r\n                break;\r\n            case \")\":\r\n                t = new token_1.Token(token_1.TokenType.RPAREN, current);\r\n                break;\r\n            case \",\":\r\n                t = new token_1.Token(token_1.TokenType.COMMA, current);\r\n                break;\r\n            case \"+\":\r\n                t = new token_1.Token(token_1.TokenType.PlUS, current);\r\n                break;\r\n            case \"-\":\r\n                t = new token_1.Token(token_1.TokenType.MINUS, current);\r\n                break;\r\n            case \"!\":\r\n                if (this.Peek() == \"=\") {\r\n                    let s = this._current;\r\n                    this.Read();\r\n                    let literal = s + this._current;\r\n                    t = new token_1.Token(token_1.TokenType.NOT_EQ, s + this._current);\r\n                }\r\n                else {\r\n                    t = new token_1.Token(token_1.TokenType.BANG, current);\r\n                }\r\n                break;\r\n            case \"/\":\r\n                t = new token_1.Token(token_1.TokenType.SLASH, current);\r\n                break;\r\n            case \"*\":\r\n                t = new token_1.Token(token_1.TokenType.ASTERISK, current);\r\n                break;\r\n            case \"<\":\r\n                t = new token_1.Token(token_1.TokenType.LT, current);\r\n                break;\r\n            case \">\":\r\n                t = new token_1.Token(token_1.TokenType.GT, current);\r\n                break;\r\n            case \"{\":\r\n                t = new token_1.Token(token_1.TokenType.LBRACE, current);\r\n                break;\r\n            case \"}\":\r\n                t = new token_1.Token(token_1.TokenType.RBRACE, current);\r\n                break;\r\n            case \"\":\r\n                t = new token_1.Token(token_1.TokenType.EOF, current);\r\n                break;\r\n            case `\"`:\r\n                t = new token_1.Token(token_1.TokenType.STRING, this.ReadString());\r\n                break;\r\n            default:\r\n                // ch1p12: if call ReadXXX, then return here,\r\n                // because Read() is already called.\r\n                if (Lexer.isLetter(current)) {\r\n                    let literal = this.ReadIdentifier();\r\n                    let type = token_1.Token.LookupIdent(literal);\r\n                    return new token_1.Token(type, literal);\r\n                }\r\n                else if (Lexer.isDisit(current)) {\r\n                    let literal = this.ReadNumber();\r\n                    return new token_1.Token(token_1.TokenType.INT, literal);\r\n                }\r\n                else {\r\n                    t = new token_1.Token(token_1.TokenType.ILLEGAL, current);\r\n                    break;\r\n                }\r\n        }\r\n        this.Read();\r\n        return t;\r\n    }\r\n    Read() {\r\n        if (this._nextPosition >= this._input.length) {\r\n            this._current = \"\";\r\n        }\r\n        else {\r\n            this._current = this._input[`${this._nextPosition}`];\r\n        }\r\n        this._currentPosition = this._nextPosition;\r\n        this._nextPosition += 1;\r\n    }\r\n    ReadIdentifier() {\r\n        let pos = this._currentPosition;\r\n        while (Lexer.isLetter(this._current)) {\r\n            this.Read();\r\n        }\r\n        let v = this._input.slice(pos, this._currentPosition);\r\n        return v.join('');\r\n    }\r\n    ReadNumber() {\r\n        let pos = this._currentPosition;\r\n        while (Lexer.isDisit(this._current)) {\r\n            this.Read();\r\n        }\r\n        let v = this._input.slice(pos, this._currentPosition);\r\n        return v.join('');\r\n    }\r\n    ReadString() {\r\n        let pos = this._currentPosition + 1;\r\n        while (true) {\r\n            this.Read();\r\n            if (this._current == `\"` || this._current == \"\") {\r\n                break;\r\n            }\r\n        }\r\n        return this._input.slice(pos, this._currentPosition).join('');\r\n    }\r\n    Peek() {\r\n        if (this._nextPosition >= this._input.length) {\r\n            return \"\";\r\n        }\r\n        return this._input[`${this._nextPosition}`];\r\n    }\r\n    SkipWhiteSpace() {\r\n        while (this._current == \" \" || this._current == \"\\t\" || this._current == \"\\n\" || this._current == \"\\r\") {\r\n            this.Read();\r\n        }\r\n    }\r\n    static isLetter(s) {\r\n        let code = s.charCodeAt(0);\r\n        let a = 97;\r\n        let z = a + 26 - 1;\r\n        let A = 65;\r\n        let Z = A + 26 - 1;\r\n        return (a <= code && code <= z) || (A <= code && code <= Z);\r\n    }\r\n    static isDisit(s) {\r\n        let code = s.charCodeAt(0);\r\n        let zero = 48;\r\n        return (48 <= code && code <= zero + 9);\r\n    }\r\n}\r\nexports.Lexer = Lexer;\r\n\n\n//# sourceURL=webpack:///./src/lexer/lexer.ts?");

/***/ }),

/***/ "./src/object/environment.ts":
/*!***********************************!*\
  !*** ./src/object/environment.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction NewEnvironment() {\r\n    let env = new Environment();\r\n    env.store = new Map();\r\n    env.outer = null;\r\n    return env;\r\n}\r\nexports.NewEnvironment = NewEnvironment;\r\nfunction NewEnclosedEnvironment(outer) {\r\n    let env = NewEnvironment();\r\n    env.outer = outer;\r\n    return env;\r\n}\r\nexports.NewEnclosedEnvironment = NewEnclosedEnvironment;\r\nclass Environment {\r\n    Get(name) {\r\n        if (!this.store.has(name) && this.outer != null) {\r\n            return this.outer.Get(name);\r\n        }\r\n        return { value: this.store.get(name), exist: this.store.has(name) };\r\n    }\r\n    Set(name, v) {\r\n        this.store.set(name, v);\r\n    }\r\n}\r\nexports.Environment = Environment;\r\n\n\n//# sourceURL=webpack:///./src/object/environment.ts?");

/***/ }),

/***/ "./src/object/object.ts":
/*!******************************!*\
  !*** ./src/object/object.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Type;\r\n(function (Type) {\r\n    Type[\"NULL_OBJ\"] = \"NULL\";\r\n    Type[\"INTEGER_OBJ\"] = \"INTEGER\";\r\n    Type[\"BOOL_OBJ\"] = \"BOOL\";\r\n    Type[\"STRING_OBJ\"] = \"STRING\";\r\n    Type[\"RETURN_VALUE_OBJ\"] = \"RETURN_VALUE\";\r\n    Type[\"FUNCTION_OBJ\"] = \"FUNCTION_VALUE\";\r\n    Type[\"ERROR_OBJ\"] = \"ERROR\";\r\n})(Type = exports.Type || (exports.Type = {}));\r\nclass Integer {\r\n    constructor(v) {\r\n        this.Value = v;\r\n    }\r\n    Type() {\r\n        return Type.INTEGER_OBJ;\r\n    }\r\n    Inspect() {\r\n        return `${this.Value}`;\r\n    }\r\n}\r\nexports.Integer = Integer;\r\nclass Bool {\r\n    constructor(v) {\r\n        this.Value = v;\r\n    }\r\n    Type() {\r\n        return Type.BOOL_OBJ;\r\n    }\r\n    Inspect() {\r\n        return `${this.Value}`;\r\n    }\r\n}\r\nexports.Bool = Bool;\r\nclass String {\r\n    Type() { return Type.STRING_OBJ; }\r\n    Inspect() { return this.Value; }\r\n}\r\nexports.String = String;\r\nclass ReturnValue {\r\n    Type() { return Type.RETURN_VALUE_OBJ; }\r\n    Inspect() { return this.Value.Inspect(); }\r\n}\r\nexports.ReturnValue = ReturnValue;\r\nclass Function {\r\n    Type() { return Type.FUNCTION_OBJ; }\r\n    Inspect() {\r\n        let out = \"\";\r\n        let params = [];\r\n        this.Parameters.forEach(element => {\r\n            params.push(element.String());\r\n        });\r\n        out += \"fn\";\r\n        out += \"(\";\r\n        out += params.join(\", \");\r\n        out += \") \";\r\n        out += \"{\\n\";\r\n        out += this.Body.String();\r\n        out += \"\\n}\";\r\n        return out;\r\n    }\r\n}\r\nexports.Function = Function;\r\nclass Error {\r\n    Type() { return Type.ERROR_OBJ; }\r\n    Inspect() { return `ERROR: ${this.Message}`; }\r\n}\r\nexports.Error = Error;\r\nclass Null {\r\n    constructor() {\r\n    }\r\n    Type() {\r\n        return Type.NULL_OBJ;\r\n    }\r\n    Inspect() {\r\n        return `null`;\r\n    }\r\n}\r\nexports.Null = Null;\r\n\n\n//# sourceURL=webpack:///./src/object/object.ts?");

/***/ }),

/***/ "./src/parser/parser.ts":
/*!******************************!*\
  !*** ./src/parser/parser.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst token = __webpack_require__(/*! ../token/token */ \"./src/token/token.ts\");\r\nconst ast = __webpack_require__(/*! ../ast/ast */ \"./src/ast/ast.ts\");\r\nvar Priority;\r\n(function (Priority) {\r\n    Priority[Priority[\"LOWEST\"] = 0] = \"LOWEST\";\r\n    Priority[Priority[\"EQUALS\"] = 1] = \"EQUALS\";\r\n    Priority[Priority[\"LESSGREATER\"] = 2] = \"LESSGREATER\";\r\n    Priority[Priority[\"SUM\"] = 3] = \"SUM\";\r\n    Priority[Priority[\"PRODUCT\"] = 4] = \"PRODUCT\";\r\n    Priority[Priority[\"PREFIX\"] = 5] = \"PREFIX\";\r\n    Priority[Priority[\"CALL\"] = 6] = \"CALL\";\r\n})(Priority || (Priority = {}));\r\nvar precedences = new Map([\r\n    [token.TokenType.EQ, Priority.EQUALS],\r\n    [token.TokenType.NOT_EQ, Priority.EQUALS],\r\n    [token.TokenType.LT, Priority.LESSGREATER],\r\n    [token.TokenType.GT, Priority.LESSGREATER],\r\n    [token.TokenType.PlUS, Priority.SUM],\r\n    [token.TokenType.MINUS, Priority.SUM],\r\n    [token.TokenType.SLASH, Priority.PRODUCT],\r\n    [token.TokenType.ASTERISK, Priority.PRODUCT],\r\n    [token.TokenType.LPAREN, Priority.CALL],\r\n]);\r\nclass Parser {\r\n    static New(l) {\r\n        let p = new Parser(l);\r\n        p.NextToken();\r\n        p.NextToken();\r\n        return p;\r\n    }\r\n    constructor(l) {\r\n        this.lex = l;\r\n        this.errors = [];\r\n        this.prefixParsingFunctions = new Map();\r\n        this.infixParsingFunctions = new Map();\r\n        this.currentToken = null;\r\n        // \"this\" is lost if class method is directly used as callback.\r\n        // https://kuroeveryday.blogspot.com/2015/04/this.html.\r\n        this.registerPrefix(token.TokenType.IDENT, () => { return this.parseIdentifier(); });\r\n        this.registerPrefix(token.TokenType.INT, () => { return this.parseIntegerLiteral(); });\r\n        this.registerPrefix(token.TokenType.STRING, () => { return this.parseStringLiteral(); });\r\n        this.registerPrefix(token.TokenType.BANG, () => { return this.parsePrefixExpression(); });\r\n        this.registerPrefix(token.TokenType.MINUS, () => { return this.parsePrefixExpression(); });\r\n        this.registerPrefix(token.TokenType.TRUE, () => { return this.parseBoolean(); });\r\n        this.registerPrefix(token.TokenType.FALSE, () => { return this.parseBoolean(); });\r\n        this.registerPrefix(token.TokenType.LPAREN, () => { return this.parseGroupedExpression(); });\r\n        this.registerPrefix(token.TokenType.IF, () => { return this.parseIfExpression(); });\r\n        this.registerPrefix(token.TokenType.FUNCTION, () => { return this.parseFunctionLiteral(); });\r\n        this.registerInfix(token.TokenType.PlUS, (left) => { return this.parseInfixExpression(left); });\r\n        this.registerInfix(token.TokenType.MINUS, (left) => { return this.parseInfixExpression(left); });\r\n        this.registerInfix(token.TokenType.SLASH, (left) => { return this.parseInfixExpression(left); });\r\n        this.registerInfix(token.TokenType.ASTERISK, (left) => { return this.parseInfixExpression(left); });\r\n        this.registerInfix(token.TokenType.EQ, (left) => { return this.parseInfixExpression(left); });\r\n        this.registerInfix(token.TokenType.NOT_EQ, (left) => { return this.parseInfixExpression(left); });\r\n        this.registerInfix(token.TokenType.LT, (left) => { return this.parseInfixExpression(left); });\r\n        this.registerInfix(token.TokenType.GT, (left) => { return this.parseInfixExpression(left); });\r\n        this.registerInfix(token.TokenType.LPAREN, (left) => { return this.parseCallExpression(left); });\r\n    }\r\n    ToProgram() {\r\n        let program = new ast.Program();\r\n        program.Statements = [];\r\n        while (this.currentToken.Type != token.TokenType.EOF) {\r\n            let statement = this.ParseStatement();\r\n            if (statement != null) {\r\n                program.Statements.push(statement);\r\n            }\r\n            this.NextToken();\r\n        }\r\n        return program;\r\n    }\r\n    Errors() {\r\n        return this.errors;\r\n    }\r\n    ParseStatement() {\r\n        switch (this.currentToken.Type) {\r\n            case token.TokenType.LET:\r\n                return this.ParseLetStatement();\r\n                break;\r\n            case token.TokenType.RETURN:\r\n                return this.ParseReturnStatement();\r\n            default:\r\n                return this.ParseExpressionStatement();\r\n                break;\r\n        }\r\n    }\r\n    ParseLetStatement() {\r\n        let ls = new ast.LetStatement();\r\n        ls.Token = this.currentToken;\r\n        if (!this.expectPeek(token.TokenType.IDENT)) {\r\n            return null;\r\n        }\r\n        let i = new ast.Identifier();\r\n        i.Token = this.currentToken;\r\n        i.Value = this.currentToken.Literal;\r\n        ls.Name = i;\r\n        if (!this.expectPeek(token.TokenType.ASSIGN)) {\r\n            return null;\r\n        }\r\n        this.NextToken();\r\n        ls.Value = this.ParseExpression(Priority.LOWEST);\r\n        if (this.peekTokenIs(token.TokenType.SEMICOLON)) {\r\n            this.NextToken();\r\n        }\r\n        return ls;\r\n    }\r\n    ParseReturnStatement() {\r\n        let s = new ast.ReturnStatement();\r\n        s.Token = this.currentToken;\r\n        this.NextToken();\r\n        s.ReturnValue = this.ParseExpression(Priority.LOWEST);\r\n        if (this.peekTokenIs(token.TokenType.SEMICOLON)) {\r\n            this.NextToken();\r\n        }\r\n        return s;\r\n    }\r\n    ParseExpressionStatement() {\r\n        let se = new ast.ExpressionStatement();\r\n        se.Token = this.currentToken;\r\n        se.Expression = this.ParseExpression(Priority.LOWEST);\r\n        if (this.peekTokenIs(token.TokenType.SEMICOLON)) {\r\n            this.NextToken();\r\n        }\r\n        return se;\r\n    }\r\n    noPrefixParseError(t) {\r\n        let msg = `no prefix parse function for ${t} found`;\r\n        this.errors.push(msg);\r\n    }\r\n    ParseExpression(p) {\r\n        let prefix = this.prefixParsingFunctions.get(this.currentToken.Type);\r\n        if (prefix == null || prefix == undefined) {\r\n            this.noPrefixParseError(this.currentToken.Type);\r\n            return null;\r\n        }\r\n        let left = prefix();\r\n        while (!this.peekTokenIs(token.TokenType.SEMICOLON) && p < this.peekPrecedence()) {\r\n            let infix = this.infixParsingFunctions.get(this.peekToken.Type);\r\n            if (infix == null || infix == undefined) {\r\n                return left;\r\n            }\r\n            this.NextToken();\r\n            left = infix(left);\r\n        }\r\n        return left;\r\n    }\r\n    parseIdentifier() {\r\n        let i = new ast.Identifier();\r\n        i.Token = this.currentToken;\r\n        i.Value = this.currentToken.Literal;\r\n        return i;\r\n    }\r\n    parseIntegerLiteral() {\r\n        let l = new ast.IntegerLiteral();\r\n        l.Value = parseInt(this.currentToken.Literal);\r\n        l.Token = this.currentToken;\r\n        return l;\r\n    }\r\n    parseStringLiteral() {\r\n        let l = new ast.StringLiteral();\r\n        l.Value = this.currentToken.Literal;\r\n        l.Token = this.currentToken;\r\n        return l;\r\n    }\r\n    parseBoolean() {\r\n        let b = new ast.Bool();\r\n        b.Value = this.currentTokenIs(token.TokenType.TRUE);\r\n        b.Token = this.currentToken;\r\n        return b;\r\n    }\r\n    parsePrefixExpression() {\r\n        let ex = new ast.PrefixExpression();\r\n        ex.Token = this.currentToken;\r\n        ex.Operator = this.currentToken.Literal;\r\n        this.NextToken();\r\n        ex.Right = this.ParseExpression(Priority.PREFIX);\r\n        return ex;\r\n    }\r\n    parseInfixExpression(left) {\r\n        let ex = new ast.InfixExpression();\r\n        ex.Token = this.currentToken;\r\n        ex.Operator = this.currentToken.Literal;\r\n        ex.Left = left;\r\n        let precedence = this.currentPrecedence();\r\n        this.NextToken();\r\n        ex.Right = this.ParseExpression(precedence);\r\n        return ex;\r\n    }\r\n    parseGroupedExpression() {\r\n        this.NextToken();\r\n        let exp = this.ParseExpression(Priority.LOWEST);\r\n        if (!this.expectPeek(token.TokenType.RPAREN)) {\r\n            return null;\r\n        }\r\n        return exp;\r\n    }\r\n    parseIfExpression() {\r\n        let _if = new ast.IfExpression();\r\n        _if.Token = this.currentToken;\r\n        if (!this.expectPeek(token.TokenType.LPAREN)) {\r\n            return null;\r\n        }\r\n        this.NextToken();\r\n        _if.Condition = this.ParseExpression(Priority.LOWEST);\r\n        if (!this.expectPeek(token.TokenType.RPAREN)) {\r\n            return null;\r\n        }\r\n        if (!this.expectPeek(token.TokenType.LBRACE)) {\r\n            return null;\r\n        }\r\n        _if.Consequence = this.parseBlockStatement();\r\n        if (this.peekTokenIs(token.TokenType.ELSE)) {\r\n            this.NextToken();\r\n            if (!this.expectPeek(token.TokenType.LBRACE)) {\r\n                return null;\r\n            }\r\n            _if.Alternative = this.parseBlockStatement();\r\n        }\r\n        return _if;\r\n    }\r\n    parseBlockStatement() {\r\n        let block = new ast.BlockStatement();\r\n        block.Statements = [];\r\n        this.NextToken();\r\n        while (!this.currentTokenIs(token.TokenType.RBRACE) && !this.currentTokenIs(token.TokenType.EOF)) {\r\n            let s = this.ParseStatement();\r\n            if (s != null) {\r\n                block.Statements.push(s);\r\n            }\r\n            this.NextToken();\r\n        }\r\n        return block;\r\n    }\r\n    parseFunctionLiteral() {\r\n        let fn = new ast.FunctionLiteral();\r\n        fn.Token = this.currentToken;\r\n        if (!this.expectPeek(token.TokenType.LPAREN)) {\r\n            return null;\r\n        }\r\n        fn.Parameters = this.parseFunctionParameters();\r\n        if (!this.expectPeek(token.TokenType.LBRACE)) {\r\n            return null;\r\n        }\r\n        fn.Body = this.parseBlockStatement();\r\n        return fn;\r\n    }\r\n    parseFunctionParameters() {\r\n        let identifiers = [];\r\n        if (this.peekTokenIs(token.TokenType.RPAREN)) {\r\n            this.NextToken();\r\n            return identifiers;\r\n        }\r\n        this.NextToken();\r\n        let ident = new ast.Identifier();\r\n        ident.Token = this.currentToken;\r\n        ident.Value = this.currentToken.Literal;\r\n        identifiers.push(ident);\r\n        while (this.peekTokenIs(token.TokenType.COMMA)) {\r\n            this.NextToken();\r\n            this.NextToken();\r\n            let ident = new ast.Identifier();\r\n            ident.Token = this.currentToken;\r\n            ident.Value = this.currentToken.Literal;\r\n            identifiers.push(ident);\r\n        }\r\n        if (!this.expectPeek(token.TokenType.RPAREN)) {\r\n            return null;\r\n        }\r\n        return identifiers;\r\n    }\r\n    parseCallExpression(f) {\r\n        let exp = new ast.CallExpression();\r\n        exp.Token = this.currentToken;\r\n        exp.Function = f;\r\n        exp.Arguments = this.parseCallArguments();\r\n        return exp;\r\n    }\r\n    parseCallArguments() {\r\n        let args = [];\r\n        if (this.peekTokenIs(token.TokenType.RPAREN)) {\r\n            this.NextToken();\r\n            return args;\r\n        }\r\n        this.NextToken();\r\n        args.push(this.ParseExpression(Priority.LOWEST));\r\n        while (this.peekTokenIs(token.TokenType.COMMA)) {\r\n            this.NextToken();\r\n            this.NextToken();\r\n            args.push(this.ParseExpression(Priority.LOWEST));\r\n        }\r\n        if (!this.expectPeek(token.TokenType.RPAREN)) {\r\n            return null;\r\n        }\r\n        return args;\r\n    }\r\n    NextToken() {\r\n        this.currentToken = this.peekToken;\r\n        this.peekToken = this.lex.NextToken();\r\n    }\r\n    expectPeek(t) {\r\n        if (this.peekTokenIs(t)) {\r\n            this.NextToken();\r\n            return true;\r\n        }\r\n        this.peekError(t);\r\n        return false;\r\n    }\r\n    peekTokenIs(t) {\r\n        return this.peekToken.Type == t;\r\n    }\r\n    currentTokenIs(t) {\r\n        return this.currentToken.Type == t;\r\n    }\r\n    currentPrecedence() {\r\n        let p = precedences.get(this.currentToken.Type);\r\n        return p == undefined ? Priority.LOWEST : p;\r\n    }\r\n    peekPrecedence() {\r\n        let p = precedences.get(this.peekToken.Type);\r\n        return p == undefined ? Priority.LOWEST : p;\r\n    }\r\n    peekError(t) {\r\n        let e = `expected next token to be ${t},got ${this.peekToken.Type} instead`;\r\n        this.errors.push(e);\r\n    }\r\n    registerPrefix(t, f) {\r\n        this.prefixParsingFunctions.set(t, f);\r\n    }\r\n    registerInfix(t, f) {\r\n        this.infixParsingFunctions.set(t, f);\r\n    }\r\n}\r\nexports.Parser = Parser;\r\n\n\n//# sourceURL=webpack:///./src/parser/parser.ts?");

/***/ }),

/***/ "./src/token/token.ts":
/*!****************************!*\
  !*** ./src/token/token.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar TokenType;\r\n(function (TokenType) {\r\n    TokenType[\"ILLEGAL\"] = \"ILLEGAL\";\r\n    TokenType[\"EOF\"] = \"EOF\";\r\n    TokenType[\"IDENT\"] = \"IDENT\";\r\n    TokenType[\"INT\"] = \"INT\";\r\n    TokenType[\"STRING\"] = \"STRING\";\r\n    TokenType[\"ASSIGN\"] = \"=\";\r\n    TokenType[\"PlUS\"] = \"+\";\r\n    TokenType[\"MINUS\"] = \"-\";\r\n    TokenType[\"BANG\"] = \"!\";\r\n    TokenType[\"ASTERISK\"] = \"*\";\r\n    TokenType[\"SLASH\"] = \"/\";\r\n    TokenType[\"EQ\"] = \"==\";\r\n    TokenType[\"NOT_EQ\"] = \"!=\";\r\n    TokenType[\"LT\"] = \"<\";\r\n    TokenType[\"GT\"] = \">\";\r\n    TokenType[\"COMMA\"] = \",\";\r\n    TokenType[\"SEMICOLON\"] = \";\";\r\n    TokenType[\"LPAREN\"] = \"(\";\r\n    TokenType[\"RPAREN\"] = \")\";\r\n    TokenType[\"LBRACE\"] = \"{\";\r\n    TokenType[\"RBRACE\"] = \"}\";\r\n    TokenType[\"TRUE\"] = \"TRUE\";\r\n    TokenType[\"FALSE\"] = \"FALSE\";\r\n    TokenType[\"FUNCTION\"] = \"FUNCTION\";\r\n    TokenType[\"LET\"] = \"LET\";\r\n    TokenType[\"IF\"] = \"IF\";\r\n    TokenType[\"ELSE\"] = \"ELSE\";\r\n    TokenType[\"RETURN\"] = \"RETURN\";\r\n})(TokenType = exports.TokenType || (exports.TokenType = {}));\r\nclass Token {\r\n    constructor(t, l) {\r\n        this.Type = t;\r\n        this.Literal = l;\r\n    }\r\n    static LookupIdent(i) {\r\n        if (Token.KeyWords.has(i)) {\r\n            // don't use Token.KeyWords[i],  -> \"undefined\"\r\n            // but use Token.KeyWords.get(i) -> value for i\r\n            return Token.KeyWords.get(i);\r\n        }\r\n        return TokenType.IDENT;\r\n    }\r\n}\r\nToken.KeyWords = new Map([\r\n    [\"fn\", TokenType.FUNCTION],\r\n    [\"let\", TokenType.LET],\r\n    [\"true\", TokenType.TRUE],\r\n    [\"false\", TokenType.FALSE],\r\n    [\"if\", TokenType.IF],\r\n    [\"else\", TokenType.ELSE],\r\n    [\"return\", TokenType.RETURN],\r\n]);\r\nexports.Token = Token;\r\n\n\n//# sourceURL=webpack:///./src/token/token.ts?");

/***/ })

/******/ });